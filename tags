!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARDriver	ARDriver.cc	/^ARDriver::ARDriver(const ATANCamera &cam, ImageRef irFrameSize, GLWindow2 &glw)$/;"	f	class:ARDriver
ARDriver	ARDriver.h	/^class ARDriver$/;"	c
ATANCamera	ATANCamera.cc	/^ATANCamera::ATANCamera(string sName)$/;"	f	class:ATANCamera
ATANCamera	ATANCamera.h	/^class ATANCamera {$/;"	c
AddCamera	Bundle.cc	/^int Bundle::AddCamera(SE3<> se3CamFromWorld, bool bFixed)$/;"	f	class:Bundle
AddKeyFrame	MapMaker.cc	/^void MapMaker::AddKeyFrame(KeyFrame &k)$/;"	f	class:MapMaker
AddKeyFrameFromTopOfQueue	MapMaker.cc	/^void MapMaker::AddKeyFrameFromTopOfQueue()$/;"	f	class:MapMaker
AddMeas	Bundle.cc	/^void Bundle::AddMeas(int nCam, int nPoint, Vector<2> v2Pos, double dSigmaSquared)$/;"	f	class:Bundle
AddMenu	GLWindow2.cc	/^void GLWindow2::AddMenu(string sName, string sTitle)$/;"	f	class:GLWindow2
AddNewKeyFrame	Tracker.cc	/^void Tracker::AddNewKeyFrame()$/;"	f	class:Tracker
AddPoint	Bundle.cc	/^int Bundle::AddPoint(Vector<3> v3Pos)$/;"	f	class:Bundle
AddPointEpipolar	MapMaker.cc	/^bool MapMaker::AddPointEpipolar(KeyFrame &kSrc, $/;"	f	class:MapMaker
AddSomeMapPoints	MapMaker.cc	/^void MapMaker::AddSomeMapPoints(int nLevel)$/;"	f	class:MapMaker
ApplyGlobalScaleToMap	MapMaker.cc	/^void MapMaker::ApplyGlobalScaleToMap(double dScale)$/;"	f	class:MapMaker
ApplyGlobalTransformationToMap	MapMaker.cc	/^void MapMaker::ApplyGlobalTransformationToMap(SE3<> se3NewFromOld)$/;"	f	class:MapMaker
ApplyMotionModel	Tracker.cc	/^void Tracker::ApplyMotionModel()$/;"	f	class:Tracker
AssessTrackingQuality	Tracker.cc	/^void Tracker::AssessTrackingQuality()$/;"	f	class:Tracker
AttemptRecovery	Relocaliser.cc	/^bool Relocaliser::AttemptRecovery(KeyFrame &kCurrent)$/;"	f	class:Relocaliser
AttemptRecovery	Tracker.cc	/^bool Tracker::AttemptRecovery()$/;"	f	class:Tracker
BAD	Tracker.h	/^  enum {BAD, DODGY, GOOD} mTrackingQuality;$/;"	e	enum:Tracker::__anon2
BestHomographyFromMatches_MLESAC	HomographyInit.cc	/^void HomographyInit::BestHomographyFromMatches_MLESAC()$/;"	f	class:HomographyInit
BestPose	Relocaliser.cc	/^SE3<> Relocaliser::BestPose()$/;"	f	class:Relocaliser
Bundle	Bundle.cc	/^Bundle::Bundle(const ATANCamera &TCam)$/;"	f	class:Bundle
Bundle	Bundle.h	/^class Bundle$/;"	c
BundleAdjust	MapMaker.cc	/^void MapMaker::BundleAdjust(set<KeyFrame*> sAdjustSet, set<KeyFrame*> sFixedSet, set<MapPoint*> sMapPoints, bool bRecent)$/;"	f	class:MapMaker
BundleAdjustAll	MapMaker.cc	/^void MapMaker::BundleAdjustAll()$/;"	f	class:MapMaker
BundleAdjustRecent	MapMaker.cc	/^void MapMaker::BundleAdjustRecent()$/;"	f	class:MapMaker
BundleTriangle_UpdateM3V_LL	Bundle.cc	/^inline void BundleTriangle_UpdateM3V_LL(Matrix<3> &m3V, Matrix<2,3> &m23B)$/;"	f
BundleTriangle_UpdateM6U_LL	Bundle.cc	/^inline void BundleTriangle_UpdateM6U_LL(Matrix<6> &m6U, Matrix<2,6> &m26A)$/;"	f
Button	GLWindowMenu.h	/^  enum MenuItemType { Button, Toggle, Monitor, Slider };$/;"	e	enum:GLWindowMenu::MenuItemType
CALIB_OBJECTS	Build/OSX/Makefile	/^CALIB_OBJECTS=	GLWindow2.o\\$/;"	m
CALIB_OBJECTS	Makefile	/^CALIB_OBJECTS=	GLWindow2.o\\$/;"	m
CC	Build/OSX/Makefile	/^CC = g++ -g -O3$/;"	m
CC	Makefile	/^CC = g++$/;"	m
CHECK_RESET	MapMaker.cc	59;"	d	file:
COMPILEFLAGS	Build/OSX/Makefile	/^COMPILEFLAGS = -I \/MY_CUSTOM_INCLUDE_PATH\/ -D_OSX -D_REENTRANT$/;"	m
COMPILEFLAGS	Makefile	/^COMPILEFLAGS = -I MY_CUSTOM_INCLUDE_PATH -D_LINUX -D_REENTRANT -Wall  -O3 -march=nocona -msse3 -I\/usr\/local\/include\/eigen3 -I\/usr\/include\/suitesparse -std=c++11$/;"	m
CalcJacobian	TrackerData.h	/^  inline void CalcJacobian()$/;"	f	struct:TrackerData
CalcPlaneAligner	MapMaker.cc	/^SE3<> MapMaker::CalcPlaneAligner()$/;"	f	class:MapMaker
CalcPoseUpdate	Tracker.cc	/^Vector<6> Tracker::CalcPoseUpdate(vector<TrackerData*> vTD, double dOverrideSigma, bool bMarkOutliers)$/;"	f	class:Tracker
CalcSBIRotation	Tracker.cc	/^void Tracker::CalcSBIRotation()$/;"	f	class:Tracker
CalcSearchLevelAndWarpMatrix	PatchFinder.cc	/^int PatchFinder::CalcSearchLevelAndWarpMatrix(MapPoint &p,$/;"	f	class:PatchFinder
CalibCornerPatch	CalibCornerPatch.cc	/^CalibCornerPatch::CalibCornerPatch(int nSideSize)$/;"	f	class:CalibCornerPatch
CalibCornerPatch	CalibCornerPatch.h	/^class CalibCornerPatch$/;"	c
CalibGridCorner	CalibImage.h	/^struct CalibGridCorner$/;"	s
CalibImage	CalibImage.h	/^class CalibImage$/;"	c
Camera	Bundle.h	/^struct Camera$/;"	s
CameraCalibrator	CameraCalibrator.cc	/^CameraCalibrator::CameraCalibrator()$/;"	f	class:CameraCalibrator
CameraCalibrator	CameraCalibrator.h	/^class CameraCalibrator$/;"	c
Candidate	KeyFrame.h	/^struct Candidate$/;"	s
Cauchy	MEstimator.h	/^struct Cauchy$/;"	s
CheckFramebufferStatus	ARDriver.cc	/^static bool CheckFramebufferStatus()         $/;"	f	file:
ChooseBestDecomposition	HomographyInit.cc	/^void HomographyInit::ChooseBestDecomposition()$/;"	f	class:HomographyInit
ClearAccumulators	Bundle.cc	/^void Bundle::ClearAccumulators()$/;"	f	class:Bundle
ClosestKeyFrame	MapMaker.cc	/^KeyFrame* MapMaker::ClosestKeyFrame(KeyFrame &k)$/;"	f	class:MapMaker
Command	MapMaker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	s	class:MapMaker
Command	Tracker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	s	class:Tracker
Compute	Bundle.cc	/^int Bundle::Compute(bool *pbAbortSignal)$/;"	f	class:Bundle
Compute	HomographyInit.cc	/^bool HomographyInit::Compute(vector<HomographyMatch> vMatches, double dMaxPixelError, SE3<> &se3SecondFromFirst)$/;"	f	class:HomographyInit
Converged	Bundle.h	/^  inline bool Converged() { return mbConverged;}  \/\/ Has bundle adjustment converged?$/;"	f	class:Bundle
DODGY	Tracker.h	/^  enum {BAD, DODGY, GOOD} mTrackingQuality;$/;"	e	enum:Tracker::__anon2
DecomposeHomography	HomographyInit.cc	/^void HomographyInit::DecomposeHomography()$/;"	f	class:HomographyInit
DisableRadialDistortion	ATANCamera.cc	/^void ATANCamera::DisableRadialDistortion()$/;"	f	class:ATANCamera
DistToNearestKeyFrame	MapMaker.cc	/^double MapMaker::DistToNearestKeyFrame(KeyFrame &kCurrent)$/;"	f	class:MapMaker
Do_LM_Step	Bundle.cc	/^bool Bundle::Do_LM_Step(bool *pbAbortSignal)$/;"	f	class:Bundle
Draw	CalibImage.cc	/^void CalibGridCorner::Draw()$/;"	f	class:CalibGridCorner
Draw3DGrid	CalibImage.cc	/^void CalibImage::Draw3DGrid(ATANCamera &Camera, bool bDrawErrors)$/;"	f	class:CalibImage
DrawCamera	MapViewer.cc	/^void MapViewer::DrawCamera(SE3<> se3CfromW, bool bSmall)$/;"	f	class:MapViewer
DrawCaption	GLWindow2.cc	/^void GLWindow2::DrawCaption(string s)$/;"	f	class:GLWindow2
DrawDistortedFB	ARDriver.cc	/^void ARDriver::DrawDistortedFB()$/;"	f	class:ARDriver
DrawEye	EyeGame.cc	/^void EyeGame::DrawEye()$/;"	f	class:EyeGame
DrawFBBackGround	ARDriver.cc	/^void ARDriver::DrawFBBackGround()$/;"	f	class:ARDriver
DrawFadingGrid	ARDriver.cc	/^void ARDriver::DrawFadingGrid()$/;"	f	class:ARDriver
DrawGrid	MapViewer.cc	/^void MapViewer::DrawGrid()$/;"	f	class:MapViewer
DrawImageGrid	CalibImage.cc	/^void CalibImage::DrawImageGrid()$/;"	f	class:CalibImage
DrawMap	MapViewer.cc	/^void MapViewer::DrawMap(SE3<> se3CamFromWorld)$/;"	f	class:MapViewer
DrawMapDots	MapViewer.cc	/^void MapViewer::DrawMapDots()$/;"	f	class:MapViewer
DrawMenus	GLWindow2.cc	/^void GLWindow2::DrawMenus()$/;"	f	class:GLWindow2
DrawStuff	EyeGame.cc	/^void EyeGame::DrawStuff(Vector<3> v3CameraPos)$/;"	f	class:EyeGame
EmptyTrash	Map.cc	/^void Map::EmptyTrash()$/;"	f	class:Map
ErrorAndJacobians	CalibImage.h	/^  struct ErrorAndJacobians$/;"	s	class:CalibImage
ExpandByAngle	CalibImage.cc	/^bool CalibImage::ExpandByAngle(int nSrc, int nDirn)$/;"	f	class:CalibImage
ExpandByStep	CalibImage.cc	/^void CalibImage::ExpandByStep(int n)$/;"	f	class:CalibImage
ExpansionPotential	CalibImage.cc	/^double CalibGridCorner::ExpansionPotential()$/;"	f	class:CalibGridCorner
EyeGame	EyeGame.cc	/^EyeGame::EyeGame()$/;"	f	class:EyeGame
EyeGame	EyeGame.h	/^class EyeGame$/;"	c
FillBox	GLWindowMenu.cc	/^void GLWindowMenu::FillBox(int l, int r, int t, int b)$/;"	f	class:GLWindowMenu
FindNewError	Bundle.cc	/^double Bundle::FindNewError()$/;"	f	class:Bundle
FindPatch	MiniPatch.cc	/^bool MiniPatch::FindPatch(CVD::ImageRef &irPos, $/;"	f	class:MiniPatch
FindPatchCoarse	PatchFinder.cc	/^bool PatchFinder::FindPatchCoarse(ImageRef irPos, KeyFrame &kf, unsigned int nRange)$/;"	f	class:PatchFinder
FindShiTomasiScoreAtPoint	ShiTomasi.cc	/^double FindShiTomasiScoreAtPoint(BasicImage<byte> &image,$/;"	f
FindSigmaSquared	MEstimator.h	/^inline double Cauchy::FindSigmaSquared(std::vector<double> &vdErrorSquared)$/;"	f	class:Cauchy
FindSigmaSquared	MEstimator.h	/^inline double Huber::FindSigmaSquared(std::vector<double> &vdErrorSquared)$/;"	f	class:Huber
FindSigmaSquared	MEstimator.h	/^inline double LeastSquares::FindSigmaSquared(std::vector<double> &vdErrorSquared)$/;"	f	class:LeastSquares
FindSigmaSquared	MEstimator.h	/^inline double Tukey::FindSigmaSquared(std::vector<double> &vdErrorSquared)$/;"	f	class:Tukey
Finder	TrackerData.h	/^  PatchFinder Finder;$/;"	m	struct:TrackerData
GLWindow2	GLWindow2.cc	/^GLWindow2::GLWindow2(ImageRef irSize, string sTitle)$/;"	f	class:GLWindow2
GLWindow2	GLWindow2.h	/^class GLWindow2 : public CVD::GLWindow, public CVD::GLWindow::EventHandler$/;"	c
GLWindowMenu	GLWindowMenu.cc	/^GLWindowMenu::GLWindowMenu(string sName, string sTitle)$/;"	f	class:GLWindowMenu
GLWindowMenu	GLWindowMenu.h	/^class GLWindowMenu$/;"	c
GL_GLEXT_PROTOTYPES	ARDriver.cc	2;"	d	file:
GOOD	Tracker.h	/^  enum {BAD, DODGY, GOOD} mTrackingQuality;$/;"	e	enum:Tracker::__anon2
GUICommandCallBack	CameraCalibrator.cc	/^void CameraCalibrator::GUICommandCallBack(void* ptr, string sCommand, string sParams)$/;"	f	class:CameraCalibrator
GUICommandCallBack	GLWindow2.cc	/^void GLWindow2::GUICommandCallBack(void* ptr, string sCommand, string sParams)$/;"	f	class:GLWindow2
GUICommandCallBack	GLWindowMenu.cc	/^void GLWindowMenu::GUICommandCallBack(void *ptr, string sCommand, string sParams)$/;"	f	class:GLWindowMenu
GUICommandCallBack	MapMaker.cc	/^void MapMaker::GUICommandCallBack(void* ptr, string sCommand, string sParams)$/;"	f	class:MapMaker
GUICommandCallBack	System.cc	/^void System::GUICommandCallBack(void *ptr, string sCommand, string sParams)$/;"	f	class:System
GUICommandCallBack	Tracker.cc	/^void Tracker::GUICommandCallBack(void* ptr, string sCommand, string sParams)$/;"	f	class:Tracker
GUICommandHandler	CameraCalibrator.cc	/^void CameraCalibrator::GUICommandHandler(string sCommand, string sParams)  \/\/ Called by the callback func..$/;"	f	class:CameraCalibrator
GUICommandHandler	GLWindow2.cc	/^void GLWindow2::GUICommandHandler(string sCommand, string sParams)  \/\/ Called by the callback func..$/;"	f	class:GLWindow2
GUICommandHandler	GLWindowMenu.cc	/^void GLWindowMenu::GUICommandHandler(string sCommand, string sParams)$/;"	f	class:GLWindowMenu
GUICommandHandler	MapMaker.cc	/^void MapMaker::GUICommandHandler(string sCommand, string sParams)  \/\/ Called by the callback func..$/;"	f	class:MapMaker
GUICommandHandler	Tracker.cc	/^void Tracker::GUICommandHandler(string sCommand, string sParams)  \/\/ Called by the callback func..$/;"	f	class:Tracker
GenerateMeasLUTs	Bundle.cc	/^void Bundle::GenerateMeasLUTs()$/;"	f	class:Bundle
GenerateOffDiagScripts	Bundle.cc	/^void Bundle::GenerateOffDiagScripts()$/;"	f	class:Bundle
GetAndFillFrameBWandRGB	Build/Linux/VideoSource_Linux_DV.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB)$/;"	f	class:VideoSource
GetAndFillFrameBWandRGB	Build/Linux/VideoSource_Linux_V4L.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB)$/;"	f	class:VideoSource
GetAndFillFrameBWandRGB	Build/OSX/VideoSource_OSX.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB)$/;"	f	class:VideoSource
GetAndFillFrameBWandRGB	Build/Win32/VideoSource_Win32_CMU1394.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<CVD::byte> &imBW, Image<CVD::Rgb<CVD::byte> > &imRGB)$/;"	f	class:VideoSource
GetAndFillFrameBWandRGB	VideoSource_Linux_DV.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB)$/;"	f	class:VideoSource
GetAndFillFrameBWandRGB	VideoSource_Linux_V4L.cc	/^void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB)$/;"	f	class:VideoSource
GetCamera	Bundle.cc	/^SE3<> Bundle::GetCamera(int n)$/;"	f	class:Bundle
GetCameraParameterDerivs	ATANCamera.cc	/^Matrix<2,NUMTRACKERCAMPARAMETERS> ATANCamera::GetCameraParameterDerivs()$/;"	f	class:ATANCamera
GetCoarsePos	PatchFinder.h	/^  inline CVD::ImageRef GetCoarsePos() { return CVD::ImageRef((int) mv2CoarsePos[0], (int) mv2CoarsePos[1]);} $/;"	f	class:PatchFinder
GetCoarsePosAsVector	PatchFinder.h	/^  inline Vector<2> GetCoarsePosAsVector() { return mv2CoarsePos; }$/;"	f	class:PatchFinder
GetCov	PatchFinder.h	/^  inline Matrix<2> GetCov()$/;"	f	class:PatchFinder
GetCurrentPose	Tracker.h	/^  inline SE3<> GetCurrentPose() { return mse3CamFromWorld;}$/;"	f	class:Tracker
GetDerivsUnsafe	TrackerData.h	/^  inline void GetDerivsUnsafe(ATANCamera &Cam) $/;"	f	struct:TrackerData
GetImageSize	ATANCamera.h	/^  inline Vector<2> GetImageSize() {return mvImageSize;};$/;"	f	class:ATANCamera
GetLevel	PatchFinder.h	/^  inline int GetLevel() { return mnSearchLevel; }$/;"	f	class:PatchFinder
GetLevelScale	PatchFinder.h	/^  inline int GetLevelScale() { return LevelScale(mnSearchLevel); }$/;"	f	class:PatchFinder
GetMessageForUser	MapViewer.cc	/^string MapViewer::GetMessageForUser()$/;"	f	class:MapViewer
GetMessageForUser	Tracker.cc	/^string Tracker::GetMessageForUser()$/;"	f	class:Tracker
GetMousePoseUpdate	GLWindow2.cc	/^pair<Vector<6>, Vector<6> > GLWindow2::GetMousePoseUpdate()$/;"	f	class:GLWindow2
GetOutlierMeasurements	Bundle.cc	/^vector<pair<int, int> > Bundle::GetOutlierMeasurements()$/;"	f	class:Bundle
GetOutliers	Bundle.cc	/^set<int> Bundle::GetOutliers()$/;"	f	class:Bundle
GetPoint	Bundle.cc	/^Vector<3> Bundle::GetPoint(int n)$/;"	f	class:Bundle
GetProjectionDerivs	ATANCamera.cc	/^Matrix<2,2> ATANCamera::GetProjectionDerivs()$/;"	f	class:ATANCamera
GetSteps	CalibImage.cc	/^Matrix<2> CalibGridCorner::GetSteps(vector<CalibGridCorner> &vgc)$/;"	f	class:CalibGridCorner
GetSubPixPos	PatchFinder.h	/^  inline Vector<2> GetSubPixPos()  { return mv2SubPixPos;   }  \/\/ Get result$/;"	f	class:PatchFinder
GoodMeasCount	MapMaker.h	/^  inline int GoodMeasCount()            $/;"	f	struct:MapMakerData
GuessInitialAngles	CalibImage.cc	/^Vector<2> GuessInitialAngles(Image<byte> &im, ImageRef irCenter)$/;"	f
GuessInitialPose	CalibImage.cc	/^void CalibImage::GuessInitialPose(ATANCamera &Camera)$/;"	f	class:CalibImage
HandleBadPoints	MapMaker.cc	/^void MapMaker::HandleBadPoints()$/;"	f	class:MapMaker
HandleClick	GLWindowMenu.cc	/^bool GLWindowMenu::HandleClick(int nMouseButton, int state, int x, int y)$/;"	f	class:GLWindowMenu
HandlePendingEvents	GLWindow2.cc	/^void GLWindow2::HandlePendingEvents()$/;"	f	class:GLWindow2
HomographyDecomposition	HomographyInit.h	/^struct HomographyDecomposition$/;"	s
HomographyFromMatches	HomographyInit.cc	/^Matrix<3> HomographyInit::HomographyFromMatches(vector<HomographyMatch> vMatches)$/;"	f	class:HomographyInit
HomographyInit	HomographyInit.h	/^class HomographyInit$/;"	c
HomographyMatch	HomographyInit.h	/^struct HomographyMatch$/;"	s
Huber	MEstimator.h	/^struct Huber$/;"	s
IR_from_dirn	CalibImage.cc	/^ImageRef CalibImage::IR_from_dirn(int nDirn)$/;"	f	class:CalibImage
Init	ARDriver.cc	/^void ARDriver::Init()$/;"	f	class:ARDriver
Init	EyeGame.cc	/^void EyeGame::Init()$/;"	f	class:EyeGame
InitFromStereo	MapMaker.cc	/^bool MapMaker::InitFromStereo(KeyFrame &kF,$/;"	f	class:MapMaker
Invalid	ATANCamera.h	/^  inline bool Invalid() {  return mbInvalid;}$/;"	f	class:ATANCamera
IsCorner	CalibImage.cc	/^inline bool IsCorner(Image<byte> &im, ImageRef ir, int nGate)$/;"	f
IsDistanceToNearestKeyFrameExcessive	MapMaker.cc	/^bool MapMaker::IsDistanceToNearestKeyFrameExcessive(KeyFrame &kCurrent)$/;"	f	class:MapMaker
IsGood	Map.h	/^  inline bool IsGood() {return bGood;}$/;"	f	struct:Map
IsHomographyInlier	HomographyInit.cc	/^bool HomographyInit::IsHomographyInlier(Matrix<3> m3Homography, HomographyMatch match)$/;"	f	class:HomographyInit
Iterate	CalibCornerPatch.cc	/^double CalibCornerPatch::Iterate(Image<byte> &im)$/;"	f	class:CalibCornerPatch
IterateOnImage	CalibCornerPatch.cc	/^bool CalibCornerPatch::IterateOnImage(CalibCornerPatch::Params &params, Image<byte> &im)$/;"	f	class:CalibCornerPatch
IterateOnImageWithDrawing	CalibCornerPatch.cc	/^bool CalibCornerPatch::IterateOnImageWithDrawing(CalibCornerPatch::Params &params, Image<byte> &im)$/;"	f	class:CalibCornerPatch
IteratePosRelToTarget	SmallBlurryImage.cc	/^pair<SE2<>,double> SmallBlurryImage::IteratePosRelToTarget(SmallBlurryImage &other, int nIterations)$/;"	f	class:SmallBlurryImage
IterateSubPix	PatchFinder.cc	/^double PatchFinder::IterateSubPix(KeyFrame &kf)$/;"	f	class:PatchFinder
IterateSubPixToConvergence	PatchFinder.cc	/^bool PatchFinder::IterateSubPixToConvergence(KeyFrame &kf, int nMaxIts)$/;"	f	class:PatchFinder
KeyFrame	KeyFrame.h	/^  inline KeyFrame()$/;"	f	struct:KeyFrame
KeyFrame	KeyFrame.h	/^struct KeyFrame$/;"	s
KeyFrameLinearDist	MapMaker.cc	/^double MapMaker::KeyFrameLinearDist(KeyFrame &k1, KeyFrame &k2)$/;"	f	class:MapMaker
LEVELS	KeyFrame.h	32;"	d
LINKFLAGS	Build/OSX/Makefile	/^LINKFLAGS = -framework OpenGL -framework VecLib -L\/MY_CUSTOM_LINK_PATH\/ -lGVars3 -lcvd$/;"	m
LINKFLAGS	Makefile	/^LINKFLAGS = -L -lX11 -ltiff  -lcxsparse -lg2o_solver_csparse -lg2o_types_sba -lcholmod -lg2o_solver_eigen -lg2o_stuff -lg2o_core -lg2o_csparse_extension -lg2o_solver_cholmod -ljpeg -lpng -lglut -lGLU -lGL -ldc1394 -lXext -pthread -lGVars3 -lcvd -llapack -lcblas -lrefblas -ltmglib -lgfortran$/;"	m
LargestRadiusInImage	ATANCamera.h	/^  inline double LargestRadiusInImage() {  return mdLargestRadius; }$/;"	f	class:ATANCamera
LeastSquares	MEstimator.h	/^struct LeastSquares$/;"	s
Level	KeyFrame.h	/^  inline Level()$/;"	f	struct:Level
Level	KeyFrame.h	/^struct Level$/;"	s
LevelHelpersFiller	KeyFrame.cc	/^  LevelHelpersFiller()$/;"	f	struct:LevelHelpersFiller
LevelHelpersFiller	KeyFrame.cc	/^struct LevelHelpersFiller \/\/ Code which should be initialised on init goes here; this runs before main()$/;"	s	file:
LevelNPos	LevelHelpers.h	/^inline Vector<2> LevelNPos(Vector<2> v2RootPos, int nLevel)$/;"	f
LevelNPos	LevelHelpers.h	/^inline double LevelNPos(double dRootPos, int nLevel)$/;"	f
LevelScale	LevelHelpers.h	/^inline int LevelScale(int nLevel)$/;"	f
LevelZeroPos	LevelHelpers.h	/^inline Vector<2> LevelZeroPos(CVD::ImageRef irLevelPos, int nLevel) $/;"	f
LevelZeroPos	LevelHelpers.h	/^inline Vector<2> LevelZeroPos(Vector<2> v2LevelPos, int nLevel)$/;"	f
LevelZeroPos	LevelHelpers.h	/^inline double LevelZeroPos(double dLevelPos, int nLevel)$/;"	f
LineBox	GLWindowMenu.cc	/^void GLWindowMenu::LineBox(int l, int r, int t, int b)$/;"	f	class:GLWindowMenu
LinearUpdate	TrackerData.h	/^  inline void LinearUpdate(const Vector<6> &v6)$/;"	f	struct:TrackerData
LookAt	EyeGame.cc	/^void EyeGame::LookAt(int nEye, Vector<3> v3, double dRotLimit)$/;"	f	class:EyeGame
M2Det	SmallMatrixOpts.h	/^inline double M2Det(Matrix<2> m)$/;"	f
M2Inverse	SmallMatrixOpts.h	/^inline Matrix<2> M2Inverse(const Matrix<2> &m)$/;"	f
M3Det	SmallMatrixOpts.h	/^inline double M3Det(Matrix<3> m )$/;"	f
MLESACScore	HomographyInit.cc	/^double HomographyInit::MLESACScore(Matrix<3> m3Homography, HomographyMatch match)$/;"	f	class:HomographyInit
MakeFrameBuffer	ARDriver.cc	/^void ARDriver::MakeFrameBuffer()$/;"	f	class:ARDriver
MakeFromImage	CalibImage.cc	/^bool CalibImage::MakeFromImage(Image<byte> &im)$/;"	f	class:CalibImage
MakeFromKF	SmallBlurryImage.cc	/^void SmallBlurryImage::MakeFromKF(KeyFrame &kf, double dBlur)$/;"	f	class:SmallBlurryImage
MakeJacs	SmallBlurryImage.cc	/^void SmallBlurryImage::MakeJacs()$/;"	f	class:SmallBlurryImage
MakeKeyFrame_Lite	KeyFrame.cc	/^void KeyFrame::MakeKeyFrame_Lite(BasicImage<byte> &im)$/;"	f	class:KeyFrame
MakeKeyFrame_Rest	KeyFrame.cc	/^void KeyFrame::MakeKeyFrame_Rest()$/;"	f	class:KeyFrame
MakeShadowTex	EyeGame.cc	/^void EyeGame::MakeShadowTex()$/;"	f	class:EyeGame
MakeSharedTemplate	CalibCornerPatch.cc	/^void CalibCornerPatch::MakeSharedTemplate()$/;"	f	class:CalibCornerPatch
MakeSubPixTemplate	PatchFinder.cc	/^void PatchFinder::MakeSubPixTemplate()$/;"	f	class:PatchFinder
MakeTemplateCoarse	PatchFinder.cc	/^void PatchFinder::MakeTemplateCoarse(MapPoint &p,$/;"	f	class:PatchFinder
MakeTemplateCoarseCont	PatchFinder.cc	/^void PatchFinder::MakeTemplateCoarseCont(MapPoint &p)$/;"	f	class:PatchFinder
MakeTemplateCoarseNoWarp	PatchFinder.cc	/^void PatchFinder::MakeTemplateCoarseNoWarp(KeyFrame &k, int nLevel, ImageRef irLevelPos)$/;"	f	class:PatchFinder
MakeTemplateCoarseNoWarp	PatchFinder.cc	/^void PatchFinder::MakeTemplateCoarseNoWarp(MapPoint &p)$/;"	f	class:PatchFinder
MakeTemplateSums	PatchFinder.cc	/^inline void PatchFinder::MakeTemplateSums()$/;"	f	class:PatchFinder
MakeTemplateWithCurrentParams	CalibCornerPatch.cc	/^void CalibCornerPatch::MakeTemplateWithCurrentParams()$/;"	f	class:CalibCornerPatch
MakeUFBLinearFrustumMatrix	ATANCamera.cc	/^Matrix<4> ATANCamera::MakeUFBLinearFrustumMatrix(double near, double far)$/;"	f	class:ATANCamera
Map	Map.cc	/^Map::Map()$/;"	f	class:Map
Map	Map.h	/^struct Map$/;"	s
MapMaker	MapMaker.cc	/^MapMaker::MapMaker(Map& m, const ATANCamera &cam)$/;"	f	class:MapMaker
MapMaker	MapMaker.h	/^class MapMaker : protected CVD::Thread$/;"	c
MapMakerData	MapMaker.h	/^struct MapMakerData$/;"	s
MapPoint	MapPoint.h	/^  inline MapPoint()$/;"	f	struct:MapPoint
MapPoint	MapPoint.h	/^struct MapPoint$/;"	s
MapViewer	MapViewer.cc	/^MapViewer::MapViewer(Map &map, GLWindow2 &glw):$/;"	f	class:MapViewer
MapViewer	MapViewer.h	/^class MapViewer$/;"	c
Meas	Bundle.h	/^  inline Meas()$/;"	f	struct:Meas
Meas	Bundle.h	/^struct Meas$/;"	s
Measurement	KeyFrame.h	/^struct Measurement$/;"	s
MenuItem	GLWindowMenu.h	/^  struct MenuItem$/;"	s	class:GLWindowMenu
MenuItemType	GLWindowMenu.h	/^  enum MenuItemType { Button, Toggle, Monitor, Slider };$/;"	g	class:GLWindowMenu
MiniPatch	MiniPatch.h	/^struct MiniPatch$/;"	s
ModifyLambda_BadStep	Bundle.cc	/^void Bundle::ModifyLambda_BadStep()$/;"	f	class:Bundle
ModifyLambda_GoodStep	Bundle.cc	/^void Bundle::ModifyLambda_GoodStep()$/;"	f	class:Bundle
Monitor	GLWindowMenu.h	/^  enum MenuItemType { Button, Toggle, Monitor, Slider };$/;"	e	enum:GLWindowMenu::MenuItemType
MoveBadPointsToTrash	Map.cc	/^void Map::MoveBadPointsToTrash()$/;"	f	class:Map
NClosestKeyFrames	MapMaker.cc	/^vector<KeyFrame*> MapMaker::NClosestKeyFrames(KeyFrame &k, unsigned int N)$/;"	f	class:MapMaker
NUMTRACKERCAMPARAMETERS	ATANCamera.h	54;"	d
N_FAILED	CalibImage.h	/^const int N_FAILED=-2;$/;"	v
N_NOT_TRIED	CalibImage.h	/^const int N_NOT_TRIED=-1;$/;"	v
NeedNewKeyFrame	MapMaker.cc	/^bool MapMaker::NeedNewKeyFrame(KeyFrame &kCurrent)$/;"	f	class:MapMaker
NeighborState	CalibImage.h	/^    NeighborState() {val = N_NOT_TRIED;}$/;"	f	struct:CalibGridCorner::NeighborState
NeighborState	CalibImage.h	/^  struct NeighborState$/;"	s	struct:CalibGridCorner
NextToExpand	CalibImage.cc	/^int CalibImage::NextToExpand()$/;"	f	class:CalibImage
OBJECTS	Build/OSX/Makefile	/^OBJECTS=	main.o\\$/;"	m
OBJECTS	Makefile	/^OBJECTS=	main.o\\$/;"	m
ObjectiveScore	MEstimator.h	/^inline double Cauchy::ObjectiveScore(double dErrorSquared, const double dSigmaSquared)$/;"	f	class:Cauchy
ObjectiveScore	MEstimator.h	/^inline double Huber::ObjectiveScore(double dErrorSquared, const double dSigmaSquared)$/;"	f	class:Huber
ObjectiveScore	MEstimator.h	/^inline double LeastSquares::ObjectiveScore(double dErrorSquared, const double dSigmaSquared)$/;"	f	class:LeastSquares
ObjectiveScore	MEstimator.h	/^inline double Tukey::ObjectiveScore(double dErrorSquared, const double dSigmaSquared)$/;"	f	class:Tukey
OffDiagScriptEntry	Bundle.h	/^struct OffDiagScriptEntry$/;"	s
OnePixelDist	ATANCamera.h	/^  inline double OnePixelDist() { return mdOnePixelDist; }$/;"	f	class:ATANCamera
OptimizeOneStep	CameraCalibrator.cc	/^void CameraCalibrator::OptimizeOneStep()$/;"	f	class:CameraCalibrator
Params	CalibCornerPatch.cc	/^CalibCornerPatch::Params::Params()$/;"	f	class:CalibCornerPatch::Params
Params	CalibCornerPatch.h	/^  struct Params$/;"	s	class:CalibCornerPatch
Params	CalibImage.h	/^  CalibCornerPatch::Params Params;$/;"	m	struct:CalibGridCorner
PatchFinder	PatchFinder.cc	/^PatchFinder::PatchFinder(int nPatchSize)$/;"	f	class:PatchFinder
PatchFinder	PatchFinder.h	/^class PatchFinder$/;"	c
PixelAspectRatio	ATANCamera.h	/^  double PixelAspectRatio() { return mvFocal[1] \/ mvFocal[0];}$/;"	f	class:ATANCamera
Point	Bundle.h	/^  inline Point()$/;"	f	struct:Point
Point	Bundle.h	/^struct Point$/;"	s
Point	TrackerData.h	/^  MapPoint &Point;$/;"	m	struct:TrackerData
PrintString	GLWindow2.cc	/^void GLWindow2::PrintString(CVD::ImageRef irPos, std::string s)$/;"	f	class:GLWindow2
Project	ATANCamera.cc	/^Vector<2> ATANCamera::Project(const Vector<2>& vCam){$/;"	f	class:ATANCamera
Project	ATANCamera.h	/^  inline Vector<2> Project(CVD::ImageRef ir) { return Project(vec(ir)); }$/;"	f	class:ATANCamera
Project	CalibImage.cc	/^vector<CalibImage::ErrorAndJacobians> CalibImage::Project(ATANCamera &Camera)$/;"	f	class:CalibImage
Project	TrackerData.h	/^  inline void Project(const SE3<> &se3CFromW, ATANCamera &Cam)$/;"	f	struct:TrackerData
ProjectAndDerivs	TrackerData.h	/^  inline void ProjectAndDerivs(SE3<> &se3, ATANCamera &Cam)$/;"	f	struct:TrackerData
ProjectAndFindSquaredError	Bundle.cc	/^inline void Bundle::ProjectAndFindSquaredError(Meas &meas)$/;"	f	class:Bundle
QueueSize	MapMaker.h	/^  int  QueueSize() { return mvpKeyFrameQueue.size() ;} \/\/ How many KFs in the queue waiting to be added?$/;"	f	class:MapMaker
ReFindFromFailureQueue	MapMaker.cc	/^void MapMaker::ReFindFromFailureQueue()$/;"	f	class:MapMaker
ReFindInSingleKeyFrame	MapMaker.cc	/^int MapMaker::ReFindInSingleKeyFrame(KeyFrame &k)$/;"	f	class:MapMaker
ReFindNewlyMade	MapMaker.cc	/^void MapMaker::ReFindNewlyMade()$/;"	f	class:MapMaker
ReFind_Common	MapMaker.cc	/^bool MapMaker::ReFind_Common(KeyFrame &k, MapPoint &p)$/;"	f	class:MapMaker
RefineHomographyWithInliers	HomographyInit.cc	/^void HomographyInit::RefineHomographyWithInliers()$/;"	f	class:HomographyInit
RefreshParams	ATANCamera.cc	/^void ATANCamera::RefreshParams() $/;"	f	class:ATANCamera
RefreshPixelVectors	MapPoint.cc	/^void MapPoint::RefreshPixelVectors()$/;"	f	class:MapPoint
RefreshSceneDepth	MapMaker.cc	/^void MapMaker::RefreshSceneDepth(KeyFrame *pKF)$/;"	f	class:MapMaker
Relocaliser	Relocaliser.cc	/^Relocaliser::Relocaliser(Map &map, ATANCamera &camera)$/;"	f	class:Relocaliser
Relocaliser	Relocaliser.h	/^class Relocaliser$/;"	c
Render	ARDriver.cc	/^void ARDriver::Render(Image<Rgb<byte> > &imFrame, SE3<> se3CfromW)$/;"	f	class:ARDriver
Render	GLWindowMenu.cc	/^void GLWindowMenu::Render(int nTop, int nHeight, int nWidth, GLWindow2 &glw)$/;"	f	class:GLWindowMenu
RenderGrid	Tracker.cc	/^void Tracker::RenderGrid()$/;"	f	class:Tracker
ReprojectPoint	MapMaker.cc	/^Vector<3> MapMaker::ReprojectPoint(SE3<> se3AfromB, const Vector<2> &v2A, const Vector<2> &v2B)$/;"	f	class:MapMaker
RequestReset	MapMaker.cc	/^void MapMaker::RequestReset()$/;"	f	class:MapMaker
Reset	ARDriver.cc	/^void ARDriver::Reset()$/;"	f	class:ARDriver
Reset	CameraCalibrator.cc	/^void CameraCalibrator::Reset()$/;"	f	class:CameraCalibrator
Reset	EyeGame.cc	/^void EyeGame::Reset()$/;"	f	class:EyeGame
Reset	Map.cc	/^void Map::Reset()$/;"	f	class:Map
Reset	MapMaker.cc	/^void MapMaker::Reset()$/;"	f	class:MapMaker
Reset	Tracker.cc	/^void Tracker::Reset()$/;"	f	class:Tracker
ResetDone	MapMaker.cc	/^bool MapMaker::ResetDone()$/;"	f	class:MapMaker
Run	CameraCalibrator.cc	/^void CameraCalibrator::Run()$/;"	f	class:CameraCalibrator
Run	System.cc	/^void System::Run()$/;"	f	class:System
SE3fromSE2	SmallBlurryImage.cc	/^SE3<> SmallBlurryImage::SE3fromSE2(SE2<> se2, ATANCamera camera) $/;"	f	class:SmallBlurryImage
SRC_EPIPOLAR	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	e	enum:Measurement::__anon3
SRC_REFIND	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	e	enum:Measurement::__anon3
SRC_ROOT	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	e	enum:Measurement::__anon3
SRC_TRACKER	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	e	enum:Measurement::__anon3
SRC_TRAIL	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	e	enum:Measurement::__anon3
SSDAtPoint	MiniPatch.cc	/^inline int MiniPatch::SSDAtPoint(CVD::BasicImage<CVD::byte> &im, const CVD::ImageRef &ir)$/;"	f	class:MiniPatch
SampleFromImage	MiniPatch.cc	/^void MiniPatch::SampleFromImage(ImageRef irPos, BasicImage<byte> &im)$/;"	f	class:MiniPatch
SampsonusError	HomographyInit.cc	/^static double SampsonusError(Vector<2> &v2Dash, const Matrix<3> &m3Essential, Vector<2> &v2)$/;"	f	file:
ScoreKFs	Relocaliser.cc	/^void Relocaliser::ScoreKFs(KeyFrame &kCurrent)$/;"	f	class:Relocaliser
SearchForPoints	Tracker.cc	/^int Tracker::SearchForPoints(vector<TrackerData*> &vTD, int nRange, int nSubPixIts)$/;"	f	class:Tracker
SetImageSize	ATANCamera.cc	/^void ATANCamera::SetImageSize(Vector<2> vImageSize)$/;"	f	class:ATANCamera
SetImageSize	ATANCamera.h	/^  inline void SetImageSize(CVD::ImageRef irImageSize) {SetImageSize(vec(irImageSize));};$/;"	f	class:ATANCamera
SetSubPixPos	PatchFinder.h	/^  void SetSubPixPos(Vector<2> v2)  { mv2SubPixPos = v2;     }  \/\/ Set starting point$/;"	f	class:PatchFinder
SetupFrustum	MapViewer.cc	/^void MapViewer::SetupFrustum()$/;"	f	class:MapViewer
SetupModelView	MapViewer.cc	/^void MapViewer::SetupModelView(SE3<> se3WorldFromCurrent)$/;"	f	class:MapViewer
SetupUnitOrtho	GLWindow2.cc	/^void GLWindow2::SetupUnitOrtho()$/;"	f	class:GLWindow2
SetupVideoOrtho	GLWindow2.cc	/^void GLWindow2::SetupVideoOrtho()$/;"	f	class:GLWindow2
SetupVideoRasterPosAndZoom	GLWindow2.cc	/^void GLWindow2::SetupVideoRasterPosAndZoom()$/;"	f	class:GLWindow2
SetupViewport	GLWindow2.cc	/^void GLWindow2::SetupViewport()$/;"	f	class:GLWindow2
SetupWindowOrtho	GLWindow2.cc	/^void GLWindow2::SetupWindowOrtho()$/;"	f	class:GLWindow2
Size	Build/Linux/VideoSource_Linux_DV.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Size	Build/Linux/VideoSource_Linux_V4L.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Size	Build/OSX/VideoSource_OSX.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Size	Build/Win32/VideoSource_Win32_CMU1394.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Size	VideoSource_Linux_DV.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Size	VideoSource_Linux_V4L.cc	/^ImageRef VideoSource::Size()$/;"	f	class:VideoSource
Slider	GLWindowMenu.h	/^  enum MenuItemType { Button, Toggle, Monitor, Slider };$/;"	e	enum:GLWindowMenu::MenuItemType
SmallBlurryImage	SmallBlurryImage.cc	/^SmallBlurryImage::SmallBlurryImage()$/;"	f	class:SmallBlurryImage
SmallBlurryImage	SmallBlurryImage.cc	/^SmallBlurryImage::SmallBlurryImage(KeyFrame &kf, double dBlur)$/;"	f	class:SmallBlurryImage
SmallBlurryImage	SmallBlurryImage.h	/^class SmallBlurryImage$/;"	c
Source	KeyFrame.h	/^  enum {SRC_TRACKER, SRC_REFIND, SRC_ROOT, SRC_TRAIL, SRC_EPIPOLAR} Source; \/\/ Where has this measurement come frome?$/;"	m	struct:Measurement	typeref:enum:Measurement::__anon3
SquareRootWeight	MEstimator.h	/^inline double Cauchy::SquareRootWeight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Cauchy
SquareRootWeight	MEstimator.h	/^inline double Huber::SquareRootWeight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Huber
SquareRootWeight	MEstimator.h	/^inline double LeastSquares::SquareRootWeight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:LeastSquares
SquareRootWeight	MEstimator.h	/^inline double Tukey::SquareRootWeight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Tukey
SubMenu	GLWindowMenu.h	/^  struct SubMenu$/;"	s	class:GLWindowMenu
SumXMM_16	PatchFinder.cc	/^inline int SumXMM_16(__m128i &target)$/;"	f
SumXMM_32	PatchFinder.cc	/^inline int SumXMM_32(__m128i &target)$/;"	f
System	System.cc	/^System::System()$/;"	f	class:System
System	System.h	/^class System$/;"	c
TRAIL_TRACKING_COMPLETE	Tracker.h	/^	TRAIL_TRACKING_COMPLETE} mnInitialStage;  \/\/ How far are we towards making the initial map?$/;"	e	enum:Tracker::__anon1
TRAIL_TRACKING_NOT_STARTED	Tracker.h	/^  enum {TRAIL_TRACKING_NOT_STARTED, $/;"	e	enum:Tracker::__anon1
TRAIL_TRACKING_STARTED	Tracker.h	/^	TRAIL_TRACKING_STARTED, $/;"	e	enum:Tracker::__anon1
TemplateBad	PatchFinder.h	/^  inline bool TemplateBad()      { return mbTemplateBad;} $/;"	f	class:PatchFinder
ThinCandidates	MapMaker.cc	/^void MapMaker::ThinCandidates(KeyFrame &k, int nLevel)$/;"	f	class:MapMaker
Toggle	GLWindowMenu.h	/^  enum MenuItemType { Button, Toggle, Monitor, Slider };$/;"	e	enum:GLWindowMenu::MenuItemType
TrackForInitialMap	Tracker.cc	/^void Tracker::TrackForInitialMap()$/;"	f	class:Tracker
TrackFrame	Tracker.cc	/^void Tracker::TrackFrame(Image<byte> &imFrame, bool bDraw)$/;"	f	class:Tracker
TrackMap	Tracker.cc	/^void Tracker::TrackMap()$/;"	f	class:Tracker
Tracker	Tracker.cc	/^Tracker::Tracker(ImageRef irVideoSize, const ATANCamera &c, Map &m, MapMaker &mm) : $/;"	f	class:Tracker
Tracker	Tracker.h	/^class Tracker$/;"	c
TrackerData	TrackerData.h	/^TrackerData(MapPoint *pMapPoint) $/;"	f	struct:TrackerData
TrackerData	TrackerData.h	/^struct TrackerData$/;"	s
Trail	Tracker.h	/^struct Trail    \/\/ This struct is used for initial correspondences of the first stereo pair.$/;"	s
TrailTracking_Advance	Tracker.cc	/^int Tracker::TrailTracking_Advance()$/;"	f	class:Tracker
TrailTracking_Start	Tracker.cc	/^void Tracker::TrailTracking_Start()$/;"	f	class:Tracker
Tukey	MEstimator.h	/^struct Tukey$/;"	s
UFBLinearProject	ATANCamera.h	/^inline Vector<2> ATANCamera::UFBLinearProject(const Vector<2>& camframe)$/;"	f	class:ATANCamera
UFBLinearUnProject	ATANCamera.h	/^inline Vector<2> ATANCamera::UFBLinearUnProject(const Vector<2>& fbframe)$/;"	f	class:ATANCamera
UFBProject	ATANCamera.cc	/^Vector<2> ATANCamera::UFBProject(const Vector<2>& vCam)$/;"	f	class:ATANCamera
UFBUnProject	ATANCamera.cc	/^Vector<2> ATANCamera::UFBUnProject(const Vector<2>& v2Im)$/;"	f	class:ATANCamera
UnProject	ATANCamera.cc	/^Vector<2> ATANCamera::UnProject(const Vector<2>& v2Im)$/;"	f	class:ATANCamera
UnProject	ATANCamera.h	/^  inline Vector<2> UnProject(CVD::ImageRef ir)  { return UnProject(vec(ir)); }$/;"	f	class:ATANCamera
UpdateMotionModel	Tracker.cc	/^void Tracker::UpdateMotionModel()$/;"	f	class:Tracker
UpdateParams	ATANCamera.cc	/^void ATANCamera::UpdateParams(Vector<5> vUpdate)$/;"	f	class:ATANCamera
VIDEOSOURCE	Makefile	/^VIDEOSOURCE = VideoSource_Linux_V4L.o$/;"	m
VideoSource	Build/Linux/VideoSource_Linux_DV.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
VideoSource	Build/Linux/VideoSource_Linux_V4L.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
VideoSource	Build/OSX/VideoSource_OSX.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
VideoSource	Build/Win32/VideoSource_Win32_CMU1394.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
VideoSource	VideoSource.h	/^class VideoSource$/;"	c
VideoSource	VideoSource_Linux_DV.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
VideoSource	VideoSource_Linux_V4L.cc	/^VideoSource::VideoSource()$/;"	f	class:VideoSource
WIN32_LEAN_AND_MEAN	Build/Win32/VideoSource_Win32_CMU1394.cc	6;"	d	file:
WIN32_LEAN_AND_MEAN	MapMaker.cc	21;"	d	file:
WIN32_LEAN_AND_MEAN	OpenGL.h	16;"	d
Weight	MEstimator.h	/^inline double Cauchy::Weight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Cauchy
Weight	MEstimator.h	/^inline double Huber::Weight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Huber
Weight	MEstimator.h	/^inline double LeastSquares::Weight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:LeastSquares
Weight	MEstimator.h	/^inline double Tukey::Weight(double dErrorSquared, double dSigmaSquared)$/;"	f	class:Tukey
ZMSSD	SmallBlurryImage.cc	/^double SmallBlurryImage::ZMSSD(SmallBlurryImage &other)$/;"	f	class:SmallBlurryImage
ZMSSDAtPoint	PatchFinder.cc	/^int PatchFinder::ZMSSDAtPoint(CVD::BasicImage<CVD::byte> &im, const CVD::ImageRef &ir)$/;"	f	class:PatchFinder
__AR_Driver_H	ARDriver.h	12;"	d
__ATAN_CAMERA_H	ATANCamera.h	45;"	d
__BUNDLE_H	Bundle.h	4;"	d
__CALIB_CORNER_PATCH_H	CalibCornerPatch.h	5;"	d
__CALIB_IMAGE_H	CalibImage.h	5;"	d
__CAMERACALIBRATOR_H	CameraCalibrator.h	5;"	d
__EYEGAME_H	EyeGame.h	11;"	d
__GL_WINDOW_2_H	GLWindow2.h	4;"	d
__GL_WINDOW_MENU_H	GLWindowMenu.h	5;"	d
__HOMOGRAPHY_INIT_H	HomographyInit.h	14;"	d
__KEYFRAME_H	KeyFrame.h	19;"	d
__LEVEL_HELPERS_H	LevelHelpers.h	10;"	d
__MAPMAKER_H	MapMaker.h	15;"	d
__MAP_H	Map.h	16;"	d
__MAP_POINT_H	MapPoint.h	15;"	d
__MAP_VIEWER_H	MapViewer.h	12;"	d
__MESTIMATOR_H	MEstimator.h	11;"	d
__MINI_PATCH_H	MiniPatch.h	12;"	d
__OPENGL_INCLUDES_H	OpenGL.h	3;"	d
__PATCHFINDER_H	PatchFinder.h	38;"	d
__RELOCALISER_H	Relocaliser.h	12;"	d
__SHI_TOMASI__H	ShiTomasi.h	3;"	d
__SMALLBLURRYIMAGE_H	SmallBlurryImage.h	8;"	d
__SMALL_MATRIX_OPTS	SmallMatrixOpts.h	7;"	d
__SYSTEM_H	System.h	12;"	d
__TRACKERDATA_H	TrackerData.h	4;"	d
__TRACKER_H	Tracker.h	22;"	d
aLevels	KeyFrame.h	/^  Level aLevels[LEVELS];  \/\/ Images, corners, etc lives in this array of pyramid levels$/;"	m	struct:KeyFrame
aNeighborStates	CalibImage.h	/^  NeighborState aNeighborStates[4];$/;"	m	struct:CalibGridCorner
ase3WorldFromEye	EyeGame.h	/^  SE3<> ase3WorldFromEye[4];$/;"	m	class:EyeGame
bBad	Bundle.h	/^  bool bBad;$/;"	m	struct:Meas
bBad	MapPoint.h	/^  bool bBad;$/;"	m	struct:MapPoint
bDidSubPix	TrackerData.h	/^  bool bDidSubPix;$/;"	m	struct:TrackerData
bFixed	Bundle.h	/^  bool bFixed;$/;"	m	struct:Camera
bFixed	KeyFrame.h	/^  bool bFixed;      \/\/ Is the coordinate frame of this keyframe fixed? (only true for first KF!)$/;"	m	struct:KeyFrame
bFound	TrackerData.h	/^  bool bFound;$/;"	m	struct:TrackerData
bGood	Map.h	/^  bool bGood;$/;"	m	struct:Map
bImplaneCornersCached	KeyFrame.h	/^  bool bImplaneCornersCached;           \/\/ Also keep image-plane (z=1) positions of FAST corners to speed up epipolar search$/;"	m	struct:Level
bInImage	TrackerData.h	/^  bool bInImage;        $/;"	m	struct:TrackerData
bPotentiallyVisible	TrackerData.h	/^  bool bPotentiallyVisible;$/;"	m	struct:TrackerData
bSearched	TrackerData.h	/^  bool bSearched;$/;"	m	struct:TrackerData
bSubPix	KeyFrame.h	/^  bool bSubPix; \/\/ Has this measurement been refined to sub-pixel level?$/;"	m	struct:Measurement
c	Bundle.h	/^  int c; \/\/ The camera - called j in MVG$/;"	m	struct:Meas
cout	Bundle.cc	17;"	d	file:
d	HomographyInit.h	/^  double d;$/;"	m	struct:HomographyDecomposition
dCreationTime	MapPoint.h	/^  double dCreationTime; \/\/timer.get_time() time of creation$/;"	m	struct:MapPoint
dErrorSquared	Bundle.h	/^  double dErrorSquared;$/;"	m	struct:Meas
dGain	CalibCornerPatch.h	/^    double dGain;$/;"	m	struct:CalibCornerPatch::Params
dMean	CalibCornerPatch.h	/^    double dMean;$/;"	m	struct:CalibCornerPatch::Params
dSTScore	KeyFrame.h	/^  double dSTScore;$/;"	m	struct:Candidate
dSceneDepthMean	KeyFrame.h	/^  double dSceneDepthMean;      \/\/ Hacky hueristics to improve epipolar search.$/;"	m	struct:KeyFrame
dSceneDepthSigma	KeyFrame.h	/^  double dSceneDepthSigma;$/;"	m	struct:KeyFrame
dSqrtInvNoise	Bundle.h	/^  double dSqrtInvNoise;$/;"	m	struct:Meas
dSqrtInvNoise	TrackerData.h	/^  double dSqrtInvNoise;   \/\/ Only depends on search level..$/;"	m	struct:TrackerData
foo	KeyFrame.cc	/^static LevelHelpersFiller foo;$/;"	v	file:
gavLevelColors	KeyFrame.cc	/^Vector<3> gavLevelColors[LEVELS];$/;"	v
gvnIntValue	GLWindowMenu.h	/^    GVars3::gvar2_int gvnIntValue;  \/\/ Not used by all, but used by some$/;"	m	struct:GLWindowMenu::MenuItem
im	KeyFrame.h	/^  CVD::Image<CVD::byte> im;                \/\/ The pyramid level pixels$/;"	m	struct:Level
invrtrans	ATANCamera.h	/^  inline double invrtrans(double r)$/;"	f	class:ATANCamera
irCenter	MapPoint.h	/^  CVD::ImageRef irCenter;   \/\/ This is in level-coords in the source pyramid level$/;"	m	struct:MapPoint
irCurrentPos	Tracker.h	/^  CVD::ImageRef irCurrentPos;$/;"	m	struct:Trail
irGridPos	CalibImage.h	/^  CVD::ImageRef irGridPos;$/;"	m	struct:CalibGridCorner
irImageSize	Tracker.cc	/^ImageRef TrackerData::irImageSize;  \/\/ Static member of TrackerData lives here$/;"	m	class:TrackerData	file:
irImageSize	TrackerData.h	/^  static CVD::ImageRef irImageSize;$/;"	m	struct:TrackerData
irInitialPos	Tracker.h	/^  CVD::ImageRef irInitialPos;$/;"	m	struct:Trail
irLevelPos	KeyFrame.h	/^  CVD::ImageRef irLevelPos;$/;"	m	struct:Candidate
isnan	Bundle.cc	/^inline bool isnan(double d) {return !(d==d);}$/;"	f
j	Bundle.h	/^  int j;$/;"	m	struct:OffDiagScriptEntry
k	Bundle.h	/^  int k;$/;"	m	struct:OffDiagScriptEntry
m23B	Bundle.h	/^  Matrix<2,3> m23B;$/;"	m	struct:Meas
m26A	Bundle.h	/^  Matrix<2,6> m26A;$/;"	m	struct:Meas
m26Jacobian	TrackerData.h	/^  Matrix<2,6> m26Jacobian;   \/\/ Jacobian wrt camera position$/;"	m	struct:TrackerData
m26PoseJac	CalibImage.h	/^    Matrix<2,6> m26PoseJac;$/;"	m	struct:CalibImage::ErrorAndJacobians
m2CamDerivs	Bundle.h	/^  Matrix<2> m2CamDerivs;$/;"	m	struct:Meas
m2CamDerivs	TrackerData.h	/^  Matrix<2> m2CamDerivs;  \/\/ Camera projection derivs$/;"	m	struct:TrackerData
m2NCameraJac	CalibImage.h	/^    Matrix<2,NUMTRACKERCAMPARAMETERS> m2NCameraJac;$/;"	m	struct:CalibImage::ErrorAndJacobians
m2PixelProjectionJac	HomographyInit.h	/^  Matrix<2> m2PixelProjectionJac;$/;"	m	struct:HomographyMatch
m2Warp	CalibCornerPatch.cc	/^Matrix<2> CalibCornerPatch::Params::m2Warp()$/;"	f	class:CalibCornerPatch::Params
m3Rp	HomographyInit.h	/^  Matrix<3> m3Rp;$/;"	m	struct:HomographyDecomposition
m3V	Bundle.h	/^  Matrix<3> m3V;          \/\/ Accumulator$/;"	m	struct:Point
m3VStarInv	Bundle.h	/^  Matrix<3> m3VStarInv;$/;"	m	struct:Point
m63W	Bundle.h	/^  Matrix<6,3> m63W; $/;"	m	struct:Meas
m63Y	Bundle.h	/^  Matrix<6,3> m63Y;$/;"	m	struct:Meas
m6U	Bundle.h	/^  Matrix<6> m6U;          \/\/ Accumulator$/;"	m	struct:Camera
mCamera	ARDriver.h	/^  ATANCamera mCamera;$/;"	m	class:ARDriver
mCamera	Bundle.h	/^  ATANCamera mCamera;$/;"	m	class:Bundle
mCamera	CameraCalibrator.h	/^  ATANCamera mCamera;$/;"	m	class:CameraCalibrator
mCamera	MapMaker.h	/^  ATANCamera mCamera;      \/\/ Same as the tracker's camera: N.B. not a reference variable!$/;"	m	class:MapMaker
mCamera	Relocaliser.h	/^  ATANCamera mCamera;$/;"	m	class:Relocaliser
mCamera	Tracker.h	/^  ATANCamera mCamera;             \/\/ Projection model$/;"	m	class:Tracker
mCurrentKF	Tracker.h	/^  KeyFrame mCurrentKF;            \/\/ The current working frame as a keyframe struct$/;"	m	class:Tracker
mFirstKF	Tracker.h	/^  KeyFrame mFirstKF;              \/\/ First of the stereo pair$/;"	m	class:Tracker
mGLWindow	ARDriver.h	/^  GLWindow2 &mGLWindow;$/;"	m	class:ARDriver
mGLWindow	CameraCalibrator.h	/^  GLWindow2 mGLWindow;$/;"	m	class:CameraCalibrator
mGLWindow	MapViewer.h	/^  GLWindow2 &mGLWindow;$/;"	m	class:MapViewer
mGLWindow	System.h	/^  GLWindow2 mGLWindow;$/;"	m	class:System
mGame	ARDriver.h	/^  EyeGame mGame;$/;"	m	class:ARDriver
mInheritedSteps	CalibImage.h	/^  Matrix<2> mInheritedSteps;$/;"	m	struct:CalibGridCorner
mMap	MapMaker.h	/^  Map &mMap;               \/\/ The map$/;"	m	class:MapMaker
mMap	MapViewer.h	/^  Map &mMap;$/;"	m	class:MapViewer
mMap	Relocaliser.h	/^  Map &mMap;$/;"	m	class:Relocaliser
mMap	Tracker.h	/^  Map &mMap;                      \/\/ The map, consisting of points and keyframes$/;"	m	class:Tracker
mMapMaker	Tracker.h	/^  MapMaker &mMapMaker;            \/\/ The class which maintains the map$/;"	m	class:Tracker
mMeasList	Bundle.h	/^  std::list<Meas> mMeasList;$/;"	m	class:Bundle
mMeasurements	KeyFrame.h	/^  std::map<MapPoint*, Measurement> mMeasurements;           \/\/ All the measurements associated with the keyframe$/;"	m	struct:KeyFrame
mMessageForUser	MapViewer.h	/^  std::ostringstream mMessageForUser;$/;"	m	class:MapViewer
mMessageForUser	Tracker.h	/^  std::ostringstream mMessageForUser;$/;"	m	class:Tracker
mParams	CalibCornerPatch.h	/^  Params mParams;$/;"	m	class:CalibCornerPatch
mPatch	Tracker.h	/^  MiniPatch mPatch;$/;"	m	struct:Trail
mPreviousFrameKF	Tracker.h	/^  KeyFrame mPreviousFrameKF;      \/\/ Used by trail tracking to check married matches$/;"	m	class:Tracker
mRelocaliser	Tracker.h	/^  Relocaliser mRelocaliser;       \/\/ Relocalisation module$/;"	m	class:Tracker
mTrackingQuality	Tracker.h	/^  enum {BAD, DODGY, GOOD} mTrackingQuality;$/;"	m	class:Tracker	typeref:enum:Tracker::__anon2
mVideoSource	CameraCalibrator.h	/^  VideoSource mVideoSource;$/;"	m	class:CameraCalibrator
mVideoSource	System.h	/^  VideoSource mVideoSource;$/;"	m	class:System
main	CameraCalibrator.cc	/^int main()$/;"	f
main	main.cc	/^int main()$/;"	f
manMeasAttempted	Tracker.h	/^  int manMeasAttempted[LEVELS];$/;"	m	class:Tracker
manMeasFound	Tracker.h	/^  int manMeasFound[LEVELS];$/;"	m	class:Tracker
max	GLWindowMenu.h	/^    int max;$/;"	m	struct:GLWindowMenu::MenuItem
mbBundleAbortRequested	MapMaker.h	/^  bool mbBundleAbortRequested;      \/\/ We should stop bundle adjustment$/;"	m	class:MapMaker
mbBundleConverged_Full	MapMaker.h	/^  bool mbBundleConverged_Full;    \/\/ Has global bundle adjustment converged?$/;"	m	class:MapMaker
mbBundleConverged_Recent	MapMaker.h	/^  bool mbBundleConverged_Recent;  \/\/ Has local bundle adjustment converged?$/;"	m	class:MapMaker
mbBundleRunning	MapMaker.h	/^  bool mbBundleRunning;             \/\/ Bundle adjustment is running$/;"	m	class:MapMaker
mbBundleRunningIsRecent	MapMaker.h	/^  bool mbBundleRunningIsRecent;     \/\/    ... and it's a local bundle adjustment.$/;"	m	class:MapMaker
mbConverged	Bundle.h	/^  bool mbConverged;$/;"	m	class:Bundle
mbDidCoarse	Tracker.h	/^  bool mbDidCoarse;               \/\/ Did tracking use the coarse tracking stage?$/;"	m	class:Tracker
mbDone	CameraCalibrator.h	/^  bool mbDone;$/;"	m	class:CameraCalibrator
mbDone	System.h	/^  bool mbDone;$/;"	m	class:System
mbDraw	Tracker.h	/^  bool mbDraw;                    \/\/ Should the tracker draw anything to OpenGL?$/;"	m	class:Tracker
mbFound	PatchFinder.h	/^  bool mbFound;               \/\/ Was the patch found?$/;"	m	class:PatchFinder
mbGrabNextFrame	CameraCalibrator.h	/^  bool mbGrabNextFrame;$/;"	m	class:CameraCalibrator
mbHitMaxIterations	Bundle.h	/^  bool mbHitMaxIterations;$/;"	m	class:Bundle
mbInitialised	ARDriver.h	/^  bool mbInitialised;$/;"	m	class:ARDriver
mbInitialised	EyeGame.h	/^  bool mbInitialised;$/;"	m	class:EyeGame
mbInvalid	ATANCamera.h	/^  bool mbInvalid;           \/\/ Was the last projection invalid?$/;"	m	class:ATANCamera
mbJustRecoveredSoUseCoarse	Tracker.h	/^  bool mbJustRecoveredSoUseCoarse;\/\/ Always use coarse tracking after recovery!$/;"	m	class:Tracker
mbMadeJacs	SmallBlurryImage.h	/^  bool mbMadeJacs;$/;"	m	class:SmallBlurryImage
mbResetDone	MapMaker.h	/^  bool mbResetDone;        \/\/ The reset was done.$/;"	m	class:MapMaker
mbResetRequested	MapMaker.h	/^  bool mbResetRequested;   \/\/ A reset has been requested$/;"	m	class:MapMaker
mbTemplateBad	PatchFinder.h	/^  bool mbTemplateBad;         \/\/ Error during template generation?$/;"	m	class:PatchFinder
mbUseSBIInit	Tracker.h	/^  bool mbUseSBIInit;$/;"	m	class:Tracker
mbUserPressedSpacebar	Tracker.h	/^  bool mbUserPressedSpacebar;$/;"	m	class:Tracker
md2Tan	ATANCamera.h	/^  double md2Tan;          \/\/ distortion model coeff$/;"	m	class:ATANCamera
mdBestScore	Relocaliser.h	/^  double mdBestScore;$/;"	m	class:Relocaliser
mdDistortionEnabled	ATANCamera.h	/^  double mdDistortionEnabled; \/\/ One or zero depending on if distortion is on or off.$/;"	m	class:ATANCamera
mdEyeRadius	EyeGame.h	/^  double mdEyeRadius;$/;"	m	class:EyeGame
mdLambda	Bundle.h	/^  double mdLambda;$/;"	m	class:Bundle
mdLambdaFactor	Bundle.h	/^  double mdLambdaFactor;$/;"	m	class:Bundle
mdLargestRadius	ATANCamera.h	/^  double mdLargestRadius; \/\/ Largest R in the image$/;"	m	class:ATANCamera
mdLastDistR	ATANCamera.h	/^  double mdLastDistR;       \/\/ Last z=1 distorted radius$/;"	m	class:ATANCamera
mdLastError	CalibCornerPatch.h	/^  double mdLastError;$/;"	m	class:CalibCornerPatch
mdLastFactor	ATANCamera.h	/^  double mdLastFactor;      \/\/ Last ratio of z=1 radii$/;"	m	class:ATANCamera
mdLastR	ATANCamera.h	/^  double mdLastR;           \/\/ Last z=1 radius$/;"	m	class:ATANCamera
mdMSDScaledVelocityMagnitude	Tracker.h	/^  double mdMSDScaledVelocityMagnitude; \/\/ Velocity magnitude scaled by relative scene depth.$/;"	m	class:Tracker
mdMaxPixelErrorSquared	HomographyInit.h	/^  double mdMaxPixelErrorSquared;$/;"	m	class:HomographyInit
mdMaxR	ATANCamera.h	/^  double mdMaxR;          \/\/ Largest R for which we consider projection valid$/;"	m	class:ATANCamera
mdMeanDiff	PatchFinder.h	/^  double mdMeanDiff;          \/\/ Updated during inverse composition$/;"	m	class:PatchFinder
mdMeanPixelError	CameraCalibrator.h	/^  double mdMeanPixelError;$/;"	m	class:CameraCalibrator
mdOneOver2Tan	ATANCamera.h	/^  double mdOneOver2Tan;   \/\/ distortion model coeff$/;"	m	class:ATANCamera
mdOnePixelDist	ATANCamera.h	/^  double mdOnePixelDist;  \/\/ z=1 distance covered by a single pixel offset (a rough estimate!)$/;"	m	class:ATANCamera
mdShadowHalfSize	EyeGame.h	/^  double mdShadowHalfSize;$/;"	m	class:EyeGame
mdSigmaSquared	Bundle.h	/^  double mdSigmaSquared;$/;"	m	class:Bundle
mdVelocityMagnitude	Tracker.h	/^  double mdVelocityMagnitude;     \/\/ Used to decide on coarse tracking $/;"	m	class:Tracker
mdW	ATANCamera.h	/^  double mdW;             \/\/ distortion model coeff$/;"	m	class:ATANCamera
mdWiggleScale	MapMaker.h	/^  double mdWiggleScale;  \/\/ Metric distance between the first two KeyFrames (copied from GVar)$/;"	m	class:MapMaker
mdWiggleScaleDepthNormalized	MapMaker.h	/^  double mdWiggleScaleDepthNormalized;  \/\/ The above normalized against scene depth, $/;"	m	class:MapMaker
mdWinv	ATANCamera.h	/^  double mdWinv;          \/\/ distortion model coeff$/;"	m	class:ATANCamera
meas_it	KeyFrame.h	/^typedef std::map<MapPoint*, Measurement>::iterator meas_it;  \/\/ For convenience, and to work around an emacs paren-matching bug$/;"	t
mgvdUpdateConvergenceLimit	Bundle.h	/^  GVars3::gvar3<double> mgvdUpdateConvergenceLimit;$/;"	m	class:Bundle
mgvdWiggleScale	MapMaker.h	/^  GVars3::gvar3<double> mgvdWiggleScale;   \/\/ GVar for above$/;"	m	class:MapMaker
mgvnBundleCout	Bundle.h	/^  GVars3::gvar3<int> mgvnBundleCout;$/;"	m	class:Bundle
mgvnDisableDistortion	CameraCalibrator.h	/^  GVars3::gvar3<int> mgvnDisableDistortion;$/;"	m	class:CameraCalibrator
mgvnEnabled	GLWindowMenu.h	/^  GVars3::gvar2_int mgvnEnabled;$/;"	m	class:GLWindowMenu
mgvnMaxIterations	Bundle.h	/^  GVars3::gvar3<int> mgvnMaxIterations;$/;"	m	class:Bundle
mgvnMenuItemWidth	GLWindowMenu.h	/^  GVars3::gvar2_int mgvnMenuItemWidth;$/;"	m	class:GLWindowMenu
mgvnMenuTextOffset	GLWindowMenu.h	/^  GVars3::gvar2_int mgvnMenuTextOffset;$/;"	m	class:GLWindowMenu
mgvnOptimizing	CameraCalibrator.h	/^  GVars3::gvar3<int> mgvnOptimizing;$/;"	m	class:CameraCalibrator
mgvnShowImage	CameraCalibrator.h	/^  GVars3::gvar3<int> mgvnShowImage;$/;"	m	class:CameraCalibrator
mgvvCameraParams	ATANCamera.h	/^  GVars3::gvar3<Vector<NUMTRACKERCAMPARAMETERS> > mgvvCameraParams; \/\/ The actual camera parameters$/;"	m	class:ATANCamera
mim	CalibImage.h	/^  CVD::Image<CVD::byte> mim;$/;"	m	class:CalibImage
mimAngleJacs	CalibCornerPatch.h	/^  CVD::Image<Vector<2> > mimAngleJacs;$/;"	m	class:CalibCornerPatch
mimFrameBW	System.h	/^  CVD::Image<CVD::byte> mimFrameBW;$/;"	m	class:System
mimFrameRGB	System.h	/^  CVD::Image<CVD::Rgb<CVD::byte> > mimFrameRGB;$/;"	m	class:System
mimGradients	CalibCornerPatch.h	/^  CVD::Image<Vector<2> > mimGradients;$/;"	m	class:CalibCornerPatch
mimImageJacs	SmallBlurryImage.h	/^  CVD::Image<Vector<2> > mimImageJacs;$/;"	m	class:SmallBlurryImage
mimJacs	PatchFinder.h	/^  CVD::Image<std::pair<float,float> > mimJacs;  \/\/ Inverse composition jacobians; stored as floats to save a bit of space.$/;"	m	class:PatchFinder
mimOrigPatch	MiniPatch.h	/^  CVD::Image<CVD::byte> mimOrigPatch;  \/\/ Original pixels$/;"	m	struct:MiniPatch
mimSharedSourceTemplate	CalibCornerPatch.h	/^  static CVD::Image<float> mimSharedSourceTemplate;$/;"	m	class:CalibCornerPatch
mimSmall	SmallBlurryImage.h	/^  CVD::Image<CVD::byte> mimSmall;$/;"	m	class:SmallBlurryImage
mimTemplate	CalibCornerPatch.h	/^  CVD::Image<float> mimTemplate;$/;"	m	class:CalibCornerPatch
mimTemplate	PatchFinder.h	/^  CVD::Image<CVD::byte> mimTemplate;   \/\/ The matching template$/;"	m	class:PatchFinder
mimTemplate	SmallBlurryImage.h	/^  CVD::Image<float> mimTemplate;$/;"	m	class:SmallBlurryImage
min	GLWindowMenu.h	/^    int min;$/;"	m	struct:GLWindowMenu::MenuItem
mirCenter	PatchFinder.h	/^  CVD::ImageRef mirCenter;    \/\/ Quantized location of the center pixel of the NxN pixel template$/;"	m	class:PatchFinder
mirFBSize	ARDriver.h	/^  ImageRef mirFBSize;$/;"	m	class:ARDriver
mirFrameSize	ARDriver.h	/^  ImageRef mirFrameSize;$/;"	m	class:ARDriver
mirLastMousePos	GLWindow2.h	/^  CVD::ImageRef mirLastMousePos;$/;"	m	class:GLWindow2
mirPredictedPos	PatchFinder.h	/^  CVD::ImageRef mirPredictedPos;  \/\/ Search center location of FindPatchCoarse in L0$/;"	m	class:PatchFinder
mirSize	SmallBlurryImage.h	/^  static CVD::ImageRef mirSize;$/;"	m	class:SmallBlurryImage
mirSize	Tracker.h	/^  CVD::ImageRef mirSize;          \/\/ Image size of whole image$/;"	m	class:Tracker
mirSize	VideoSource.h	/^  CVD::ImageRef mirSize;$/;"	m	class:VideoSource
mirVideoSize	GLWindow2.h	/^  CVD::ImageRef mirVideoSize;   \/\/ The size of the source video material.$/;"	m	class:GLWindow2
mlTrails	Tracker.h	/^  std::list<Trail> mlTrails;      \/\/ Used by trail tracking$/;"	m	class:Tracker
mm2LastWarpMatrix	PatchFinder.h	/^  Matrix<2> mm2LastWarpMatrix;       \/\/ What was the last warp matrix this PatchFinder used?$/;"	m	class:PatchFinder
mm2WarpInverse	PatchFinder.h	/^  Matrix<2> mm2WarpInverse;   \/\/ Warping matrix$/;"	m	class:PatchFinder
mm3BestHomography	HomographyInit.h	/^  Matrix<3> mm3BestHomography;$/;"	m	class:HomographyInit
mm3HInv	PatchFinder.h	/^  Matrix<3> mm3HInv;          \/\/ Inverse composition JtJ^-1$/;"	m	class:PatchFinder
mmSubMenus	GLWindowMenu.h	/^  std::map<std::string, SubMenu> mmSubMenus;$/;"	m	class:GLWindowMenu
mnAccepted	Bundle.h	/^  int mnAccepted;$/;"	m	class:Bundle
mnBest	Relocaliser.h	/^  int mnBest;$/;"	m	class:Relocaliser
mnCamsToUpdate	Bundle.h	/^  int mnCamsToUpdate;$/;"	m	class:Bundle
mnCounter	ARDriver.h	/^  int mnCounter;$/;"	m	class:ARDriver
mnCounter	Bundle.h	/^  int mnCounter;$/;"	m	class:Bundle
mnEyeDisplayList	EyeGame.h	/^  GLuint mnEyeDisplayList;$/;"	m	class:EyeGame
mnFrame	Tracker.h	/^  int mnFrame;                    \/\/ Frames processed since last reset$/;"	m	class:Tracker
mnFrameBuffer	ARDriver.h	/^  GLuint mnFrameBuffer;$/;"	m	class:ARDriver
mnFrameBufferTex	ARDriver.h	/^  GLuint mnFrameBufferTex;$/;"	m	class:ARDriver
mnFrameCounter	EyeGame.h	/^  int mnFrameCounter;$/;"	m	class:EyeGame
mnFrameTex	ARDriver.h	/^  GLuint mnFrameTex;$/;"	m	class:ARDriver
mnHalfPatchSize	MiniPatch.cc	/^int MiniPatch::mnHalfPatchSize = 4;$/;"	m	class:MiniPatch	file:
mnHalfPatchSize	MiniPatch.h	/^  static int mnHalfPatchSize;     \/\/ How big is the patch?$/;"	m	struct:MiniPatch
mnInitialStage	Tracker.h	/^	TRAIL_TRACKING_COMPLETE} mnInitialStage;  \/\/ How far are we towards making the initial map?$/;"	m	class:Tracker	typeref:enum:Tracker::__anon1
mnLastKeyFrameDropped	Tracker.h	/^  int mnLastKeyFrameDropped;      \/\/ Counter of last keyframe inserted.$/;"	m	class:Tracker
mnLeftMostCoord	GLWindowMenu.h	/^  int mnLeftMostCoord;$/;"	m	class:GLWindowMenu
mnLostFrames	Tracker.h	/^  int mnLostFrames;$/;"	m	class:Tracker
mnMaxSSD	MiniPatch.cc	/^int MiniPatch::mnMaxSSD = 9999;$/;"	m	class:MiniPatch	file:
mnMaxSSD	MiniPatch.h	/^  static int mnMaxSSD;            \/\/ Max SSD for matches?$/;"	m	struct:MiniPatch
mnMaxSSD	PatchFinder.h	/^  int mnMaxSSD; \/\/ This is the max ZMSSD for a valid match. It's set in the constructor.$/;"	m	class:PatchFinder
mnMenuHeight	GLWindowMenu.h	/^  int mnMenuHeight;$/;"	m	class:GLWindowMenu
mnMenuTop	GLWindowMenu.h	/^  int mnMenuTop;$/;"	m	class:GLWindowMenu
mnPatchSize	PatchFinder.h	/^  int mnPatchSize; \/\/ Size of one side of the matching template.$/;"	m	class:PatchFinder
mnRange	MiniPatch.cc	/^int MiniPatch::mnRange = 10;$/;"	m	class:MiniPatch	file:
mnRange	MiniPatch.h	/^  static int mnRange;             \/\/ How far to search? $/;"	m	struct:MiniPatch
mnSearchLevel	PatchFinder.h	/^  int mnSearchLevel;          \/\/ Search level in input pyramid$/;"	m	class:PatchFinder
mnShadowTex	EyeGame.h	/^  GLuint mnShadowTex;$/;"	m	class:EyeGame
mnStartRow	Bundle.h	/^  int mnStartRow;$/;"	m	class:Bundle
mnTemplateSum	PatchFinder.h	/^  int mnTemplateSum;    \/\/ Cached pixel-sum of the coarse template$/;"	m	class:PatchFinder
mnTemplateSumSq	PatchFinder.h	/^  int mnTemplateSumSq;  \/\/ Cached pixel-squared sum of the coarse template$/;"	m	class:PatchFinder
mnTextOffset	GLWindowMenu.h	/^  int mnTextOffset;$/;"	m	class:GLWindowMenu
mnWidth	GLWindowMenu.h	/^  int mnWidth;$/;"	m	class:GLWindowMenu
mpARDriver	System.h	/^  ARDriver *mpARDriver;$/;"	m	class:System
mpCamera	System.h	/^  ATANCamera *mpCamera;$/;"	m	class:System
mpLastTemplateMapPoint	PatchFinder.h	/^  MapPoint *mpLastTemplateMapPoint;  \/\/ Which was the last map point this PatchFinder used?$/;"	m	class:PatchFinder
mpMap	System.h	/^  Map *mpMap; $/;"	m	class:System
mpMapMaker	System.h	/^  MapMaker *mpMapMaker; $/;"	m	class:System
mpMapViewer	System.h	/^  MapViewer *mpMapViewer;$/;"	m	class:System
mpSBILastFrame	Tracker.h	/^  SmallBlurryImage *mpSBILastFrame;$/;"	m	class:Tracker
mpSBIThisFrame	Tracker.h	/^  SmallBlurryImage *mpSBIThisFrame;$/;"	m	class:Tracker
mpTracker	System.h	/^  Tracker *mpTracker; $/;"	m	class:System
mpbAbortSignal	Bundle.h	/^  bool *mpbAbortSignal;$/;"	m	class:Bundle
mptr	VideoSource.h	/^  void *mptr;$/;"	m	class:VideoSource
mqNewQueue	MapMaker.h	/^  std::queue<MapPoint*> mqNewQueue;   \/\/ Queue of newly-made map points to re-find in other KeyFrames$/;"	m	class:MapMaker
msCurrentSubMenu	GLWindowMenu.h	/^  std::string msCurrentSubMenu;$/;"	m	class:GLWindowMenu
msName	ATANCamera.h	/^  std::string msName;$/;"	m	class:ATANCamera
msName	GLWindowMenu.h	/^  std::string msName;$/;"	m	class:GLWindowMenu
msTitle	GLWindowMenu.h	/^  std::string msTitle;$/;"	m	class:GLWindowMenu
mse2	Relocaliser.h	/^  SE2<> mse2;$/;"	m	class:Relocaliser
mse3	ARDriver.h	/^  SE3<> mse3;$/;"	m	class:ARDriver
mse3Best	Relocaliser.h	/^  SE3<> mse3Best;$/;"	m	class:Relocaliser
mse3CamFromWorld	CalibImage.h	/^  SE3<> mse3CamFromWorld;$/;"	m	class:CalibImage
mse3CamFromWorld	Tracker.h	/^  SE3<> mse3CamFromWorld;           \/\/ Camera pose: this is what the tracker updates every frame.$/;"	m	class:Tracker
mse3StartPos	Tracker.h	/^  SE3<> mse3StartPos;               \/\/ What the camera pose was at the start of the frame.$/;"	m	class:Tracker
mse3ViewerFromWorld	MapViewer.h	/^  SE3<> mse3ViewerFromWorld;$/;"	m	class:MapViewer
mv2CoarsePos	PatchFinder.h	/^  Vector<2> mv2CoarsePos;     \/\/ In the scale of level 0; hence the use of vector rather than ImageRef$/;"	m	class:PatchFinder
mv2SubPixPos	PatchFinder.h	/^  Vector<2> mv2SubPixPos;     \/\/ In the scale of level 0$/;"	m	class:PatchFinder
mv3MassCenter	MapViewer.h	/^  Vector<3> mv3MassCenter;$/;"	m	class:MapViewer
mv6CameraVelocity	Tracker.h	/^  Vector<6> mv6CameraVelocity;    \/\/ Motion model$/;"	m	class:Tracker
mv6SBIRot	Tracker.h	/^  Vector<6> mv6SBIRot;$/;"	m	class:Tracker
mvCalibImgs	CameraCalibrator.h	/^  std::vector<CalibImage> mvCalibImgs;$/;"	m	class:CameraCalibrator
mvCameras	Bundle.h	/^  std::vector<Camera> mvCameras;$/;"	m	class:Bundle
mvCenter	ATANCamera.h	/^  Vector<2> mvCenter;     \/\/ Pixel projection center$/;"	m	class:ATANCamera
mvCorners	CalibImage.h	/^  std::vector<CVD::ImageRef> mvCorners;$/;"	m	class:CalibImage
mvDecompositions	HomographyInit.h	/^  std::vector<HomographyDecomposition> mvDecompositions;$/;"	m	class:HomographyInit
mvDefaultParams	ATANCamera.cc	/^const Vector<NUMTRACKERCAMPARAMETERS> ATANCamera::mvDefaultParams = makeVector(0.5, 0.75, 0.5, 0.5, 0.1);$/;"	m	class:ATANCamera	file:
mvDefaultParams	ATANCamera.h	/^  static const Vector<NUMTRACKERCAMPARAMETERS> mvDefaultParams;$/;"	m	class:ATANCamera
mvFailureQueue	MapMaker.h	/^  std::vector<std::pair<KeyFrame*, MapPoint*> > mvFailureQueue; \/\/ Queue of failed observations to re-find$/;"	m	class:MapMaker
mvFocal	ATANCamera.h	/^  Vector<2> mvFocal;      \/\/ Pixel focal length$/;"	m	class:ATANCamera
mvGridCorners	CalibImage.h	/^  std::vector<CalibGridCorner> mvGridCorners;$/;"	m	class:CalibImage
mvHomographyInliers	HomographyInit.h	/^  std::vector<HomographyMatch> mvHomographyInliers;$/;"	m	class:HomographyInit
mvImageSize	ATANCamera.h	/^  Vector<2> mvImageSize;  $/;"	m	class:ATANCamera
mvImplaneBR	ATANCamera.h	/^  Vector<2> mvImplaneBR;$/;"	m	class:ATANCamera
mvImplaneTL	ATANCamera.h	/^  Vector<2> mvImplaneTL;   $/;"	m	class:ATANCamera
mvInvFocal	ATANCamera.h	/^  Vector<2> mvInvFocal;   \/\/ Inverse pixel focal length$/;"	m	class:ATANCamera
mvItems	GLWindowMenu.h	/^    std::vector<MenuItem> mvItems;$/;"	m	struct:GLWindowMenu::SubMenu
mvLastCam	ATANCamera.h	/^  Vector<2> mvLastCam;      \/\/ Last z=1 coord$/;"	m	class:ATANCamera
mvLastDistCam	ATANCamera.h	/^  Vector<2> mvLastDistCam;  \/\/ Last distorted z=1 coord$/;"	m	class:ATANCamera
mvLastIm	ATANCamera.h	/^  Vector<2> mvLastIm;       \/\/ Last image\/UFB coord$/;"	m	class:ATANCamera
mvLeftPoseUpdate	GLWindow2.h	/^  TooN::Vector<6> mvLeftPoseUpdate;$/;"	m	class:GLWindow2
mvMCPoseUpdate	GLWindow2.h	/^  TooN::Vector<6> mvMCPoseUpdate;$/;"	m	class:GLWindow2
mvMatches	HomographyInit.h	/^  std::vector<HomographyMatch> mvMatches;$/;"	m	class:HomographyInit
mvMeasLUTs	Bundle.h	/^  std::vector<std::vector<Meas*> > mvMeasLUTs;  \/\/Each camera gets a per-point table of pointers to valid measurements$/;"	m	class:Bundle
mvOutlierMeasurementIdx	Bundle.h	/^  std::vector<std::pair<int,int> > mvOutlierMeasurementIdx;  \/\/ p-c pair$/;"	m	class:Bundle
mvPoints	Bundle.h	/^  std::vector<Point> mvPoints;$/;"	m	class:Bundle
mvQueuedCommands	MapMaker.h	/^  std::vector<Command> mvQueuedCommands;$/;"	m	class:MapMaker
mvQueuedCommands	Tracker.h	/^  std::vector<Command> mvQueuedCommands;$/;"	m	class:Tracker
mvUFBLinearCenter	ATANCamera.h	/^  Vector<2> mvUFBLinearCenter;$/;"	m	class:ATANCamera
mvUFBLinearFocal	ATANCamera.h	/^  Vector<2> mvUFBLinearFocal;$/;"	m	class:ATANCamera
mvUFBLinearInvFocal	ATANCamera.h	/^  Vector<2> mvUFBLinearInvFocal;$/;"	m	class:ATANCamera
mvpGLWindowMenus	GLWindow2.h	/^  std::vector<GLWindowMenu*> mvpGLWindowMenus;$/;"	m	class:GLWindow2
mvpKeyFrameQueue	MapMaker.h	/^  std::vector<KeyFrame*> mvpKeyFrameQueue;  \/\/ Queue of keyframes from the tracker waiting to be processed$/;"	m	class:MapMaker
nLevel	KeyFrame.h	/^  int nLevel;   \/\/ Which image level?$/;"	m	struct:Measurement
nMEstimatorInlierCount	MapPoint.h	/^  int nMEstimatorInlierCount;$/;"	m	struct:MapPoint
nMEstimatorOutlierCount	MapPoint.h	/^  int nMEstimatorOutlierCount;$/;"	m	struct:MapPoint
nMeasurements	Bundle.h	/^  int nMeasurements;$/;"	m	struct:Point
nOutliers	Bundle.h	/^  int nOutliers;$/;"	m	struct:Point
nScore	HomographyInit.h	/^  int nScore;$/;"	m	struct:HomographyDecomposition
nSearchLevel	TrackerData.h	/^  int nSearchLevel;$/;"	m	struct:TrackerData
nSourceLevel	MapPoint.h	/^  int nSourceLevel;         \/\/ Pyramid level in source KeyFrame$/;"	m	struct:MapPoint
nStartRow	Bundle.h	/^  int nStartRow;$/;"	m	struct:Camera
on_event	GLWindow2.cc	/^void GLWindow2::on_event(GLWindow& win, int event)$/;"	f	class:GLWindow2
on_key_down	GLWindow2.cc	/^void GLWindow2::on_key_down(GLWindow&, int k)$/;"	f	class:GLWindow2
on_mouse_down	GLWindow2.cc	/^void GLWindow2::on_mouse_down(GLWindow& win, CVD::ImageRef where, int state, int button)$/;"	f	class:GLWindow2
on_mouse_move	GLWindow2.cc	/^void GLWindow2::on_mouse_move(GLWindow& win, CVD::ImageRef where, int state)$/;"	f	class:GLWindow2
operator <	Bundle.h	/^  inline bool operator<(const Meas &rhs) const$/;"	f	struct:Meas
operator <	HomographyInit.cc	/^bool operator<(const HomographyDecomposition lhs, const HomographyDecomposition rhs)$/;"	f
operator =	KeyFrame.cc	/^Level& Level::operator=(const Level &rhs)$/;"	f	class:Level
p	Bundle.h	/^  int p; \/\/ The point  - called i in MVG$/;"	m	struct:Meas
pMMData	MapPoint.h	/^  MapMakerData *pMMData;$/;"	m	struct:MapPoint
pPatchSourceKF	MapPoint.h	/^  KeyFrame *pPatchSourceKF; \/\/ The KeyFrame the point was originally made in$/;"	m	struct:MapPoint
pSBI	KeyFrame.h	/^  SmallBlurryImage *pSBI; \/\/ The relocaliser uses this$/;"	m	struct:KeyFrame
pTData	MapPoint.h	/^  TrackerData *pTData;$/;"	m	struct:MapPoint
rtrans_factor	ATANCamera.h	/^  inline double rtrans_factor(double r)$/;"	f	class:ATANCamera
run	MapMaker.cc	/^void MapMaker::run()$/;"	f	class:MapMaker
sCameras	Bundle.h	/^  std::set<int> sCameras; \/\/ Which cameras observe this point?$/;"	m	struct:Point
sCommand	MapMaker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	m	struct:MapMaker::Command
sCommand	Tracker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	m	struct:Tracker::Command
sMeasurementKFs	MapMaker.h	/^  std::set<KeyFrame*> sMeasurementKFs;   \/\/ Which keyframes has this map point got measurements in?$/;"	m	struct:MapMakerData
sName	GLWindowMenu.h	/^    std::string sName;$/;"	m	struct:GLWindowMenu::MenuItem
sNeverRetryKFs	MapMaker.h	/^  std::set<KeyFrame*> sNeverRetryKFs;    \/\/ Which keyframes have measurements failed enough so I should never retry?$/;"	m	struct:MapMakerData
sNextMenu	GLWindowMenu.h	/^    std::string sNextMenu;$/;"	m	struct:GLWindowMenu::MenuItem
sParam	GLWindowMenu.h	/^    std::string sParam;$/;"	m	struct:GLWindowMenu::MenuItem
sParams	MapMaker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	m	struct:MapMaker::Command
sParams	Tracker.h	/^  struct Command {std::string sCommand; std::string sParams; };$/;"	m	struct:Tracker::Command
se3CfW	Bundle.h	/^  SE3<> se3CfW;$/;"	m	struct:Camera
se3CfWNew	Bundle.h	/^  SE3<> se3CfWNew;$/;"	m	struct:Camera
se3CfromW	KeyFrame.h	/^  SE3<> se3CfromW;    \/\/ The coordinate frame of this key-frame as a Camera-From-World transformation$/;"	m	struct:KeyFrame
se3SecondFromFirst	HomographyInit.h	/^  SE3<> se3SecondFromFirst;$/;"	m	struct:HomographyDecomposition
type	GLWindowMenu.h	/^    MenuItemType type;$/;"	m	struct:GLWindowMenu::MenuItem
v2Angles	CalibCornerPatch.h	/^    Vector<2> v2Angles;$/;"	m	struct:CalibCornerPatch::Params
v2CamPlaneFirst	HomographyInit.h	/^  Vector<2> v2CamPlaneFirst;$/;"	m	struct:HomographyMatch
v2CamPlaneSecond	HomographyInit.h	/^  Vector<2> v2CamPlaneSecond;$/;"	m	struct:HomographyMatch
v2Epsilon	Bundle.h	/^  Vector<2> v2Epsilon;$/;"	m	struct:Meas
v2Error	CalibImage.h	/^    Vector<2> v2Error;$/;"	m	struct:CalibImage::ErrorAndJacobians
v2Error_CovScaled	TrackerData.h	/^  Vector<2> v2Error_CovScaled;$/;"	m	struct:TrackerData
v2Found	Bundle.h	/^  Vector<2> v2Found;$/;"	m	struct:Meas
v2Found	TrackerData.h	/^  Vector<2> v2Found;      \/\/ Pixel coords of found patch (L0)$/;"	m	struct:TrackerData
v2ImPlane	TrackerData.h	/^  Vector<2> v2ImPlane;    \/\/ Coords in current cam z=1 plane$/;"	m	struct:TrackerData
v2Image	TrackerData.h	/^  Vector<2> v2Image;      \/\/ Pixel coords in LEVEL0$/;"	m	struct:TrackerData
v2Pos	CalibCornerPatch.h	/^    Vector<2> v2Pos;$/;"	m	struct:CalibCornerPatch::Params
v2RootPos	KeyFrame.h	/^  Vector<2> v2RootPos;  \/\/ Position of the measurement, REFERED TO PYRAMID LEVEL ZERO$/;"	m	struct:Measurement
v2RootPos	KeyFrame.h	/^  Vector<2> v2RootPos;$/;"	m	struct:Candidate
v3Cam	Bundle.h	/^  Vector<3> v3Cam;$/;"	m	struct:Meas
v3Cam	TrackerData.h	/^  Vector<3> v3Cam;        \/\/ Coords in current cam frame$/;"	m	struct:TrackerData
v3Center_NC	MapPoint.h	/^  Vector<3> v3Center_NC;             \/\/ Unit vector in Source-KF coords pointing at the patch center$/;"	m	struct:MapPoint
v3EpsilonB	Bundle.h	/^  Vector<3> v3EpsilonB;   \/\/ Accumulator $/;"	m	struct:Point
v3Normal_NC	MapPoint.h	/^  Vector<3> v3Normal_NC;             \/\/ Unit vector in Source-KF coords indicating patch normal$/;"	m	struct:MapPoint
v3OneDownFromCenter_NC	MapPoint.h	/^  Vector<3> v3OneDownFromCenter_NC;  \/\/ Unit vector in Source-KF coords pointing towards one pixel down of the patch center$/;"	m	struct:MapPoint
v3OneRightFromCenter_NC	MapPoint.h	/^  Vector<3> v3OneRightFromCenter_NC; \/\/ Unit vector in Source-KF coords pointing towards one pixel right of the patch center$/;"	m	struct:MapPoint
v3PixelDown_W	MapPoint.h	/^  Vector<3> v3PixelDown_W;           \/\/ 3-Vector in World coords corresponding to a one-pixel move down the source image$/;"	m	struct:MapPoint
v3PixelRight_W	MapPoint.h	/^  Vector<3> v3PixelRight_W;          \/\/ 3-Vector in World coords corresponding to a one-pixel move right the source image$/;"	m	struct:MapPoint
v3Pos	Bundle.h	/^  Vector<3> v3Pos;$/;"	m	struct:Point
v3PosNew	Bundle.h	/^  Vector<3> v3PosNew;$/;"	m	struct:Point
v3Tp	HomographyInit.h	/^  Vector<3> v3Tp;$/;"	m	struct:HomographyDecomposition
v3WorldPos	MapPoint.h	/^  Vector<3> v3WorldPos;$/;"	m	struct:MapPoint
v3n	HomographyInit.h	/^  Vector<3> v3n;$/;"	m	struct:HomographyDecomposition
v6EpsilonA	Bundle.h	/^  Vector<6> v6EpsilonA;   \/\/ Accumulator$/;"	m	struct:Camera
vCandidates	KeyFrame.h	/^  std::vector<Candidate> vCandidates;   \/\/ Potential locations of new map points$/;"	m	struct:Level
vCornerRowLUT	KeyFrame.h	/^  std::vector<int> vCornerRowLUT;          \/\/ Row-index into the FAST corners, speeds up access$/;"	m	struct:Level
vCorners	KeyFrame.h	/^  std::vector<CVD::ImageRef> vCorners;     \/\/ All FAST corners on this level$/;"	m	struct:Level
vImplaneCorners	KeyFrame.h	/^  std::vector<Vector<2> > vImplaneCorners; \/\/ Corner points un-projected into z=1-plane coordinates$/;"	m	struct:Level
vMaxCorners	KeyFrame.h	/^  std::vector<CVD::ImageRef> vMaxCorners;  \/\/ The maximal FAST corners$/;"	m	struct:Level
vOffDiagonalScript	Bundle.h	/^  std::vector<OffDiagScriptEntry> vOffDiagonalScript; \/\/ A record of all camera-camera pairs observing this point$/;"	m	struct:Point
val	CalibImage.h	/^    int val;$/;"	m	struct:CalibGridCorner::NeighborState
vpKeyFrames	Map.h	/^  std::vector<KeyFrame*> vpKeyFrames;$/;"	m	struct:Map
vpPoints	Map.h	/^  std::vector<MapPoint*> vpPoints;$/;"	m	struct:Map
vpPointsTrash	Map.h	/^  std::vector<MapPoint*> vpPointsTrash;$/;"	m	struct:Map
~GLWindowMenu	GLWindowMenu.cc	/^GLWindowMenu::~GLWindowMenu()$/;"	f	class:GLWindowMenu
~MapMaker	MapMaker.cc	/^MapMaker::~MapMaker()$/;"	f	class:MapMaker
